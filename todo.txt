complete update for changing user role from user section
16/07/2021

1. /*
RolePermissionAssignedActionSubscriber.php
ensure permission isn't already assigned before assigned to avoid duplicate entry error
*/

/*
Features

1. MVC design architecture
2. Custom PHP Framework
3. FormBuilder Component
4. PSR Caching Component
5. Session Management Component (requires Cookie Manager component)
6. Flash Messaging Component (requires Session Management Component)
7. PSR Logger component
8. Cookie Manager Component
9. Templating Component
10. Mailer component
11. UserManager Component (requires Authentication component)
12. Authentication Component
13. DataView Component
14.
*/
06/08/2021

1. render an alert on all main channel (index route) stating whether a route is unprotected ie has no permission can do this
using PHP Reflection to get all methods and check the a database if the route exists

2. create a fillable property for each model listing all fillable fields

use MagmaCore\Bundler\Bundler;
use MagmaCore\Blank\BlankBundler;
use MagmaCore\Container\ContainerFactory;

//$bundler = new Bundler((new ContainerFactory())->create(), ROOT_PATH);
//$bundler
//    ->addBundle(BlankBundler::register())
//    ->boot($bundler);
//
//$blanker = $bundler->getBundle('blanker');
//$blanker->set('name', 'Ricardo Miller');
//echo $blanker->get('name');
//var_dump($blanker);
//die;

use MagmaCore\DataObjectLayer\DataLayerClientFacade;
$client = new DataLayerClientFacade('plugin', 'user_role', 'id');

$all = $client->getClientRepository();
var_dump($all->get());
die;

php bin/console magma:create test_controller

use MagmaCore\Utility\Yaml;
// use MagmaCore\Bundler\Bundler;
use MagmaCore\Logger\LogLevel;
// use MagmaCore\Blank\BlankBundler;
use MagmaCore\Base\BaseApplication;
use MagmaCore\Http\Request;
// use MagmaCore\Container\ContainerFactory;

// $bundler = new Bundler((new ContainerFactory())->create(), ROOT_PATH);
// $bundler->addBundle(BlankBundler::register())->boot($bundler);

// $blanker = $bundler->getBundle('blanker');
// $blanker->set('name', 'Ricardo Miller');
// echo $blanker->get('name');
// var_dump($blanker);
// die;
// $request = new Request('http://bbc.co.uk');
// $request->execute();
// $response = $request->checkResponseForContent();
// var_dump($response);
// die;


$path = '';
$data = null;
$headers = [];

$read = new CurlApi(
    'https://api.publicapis.org/',
    'random?auth=null',
    $headers
);
$data = $read->show()->response()->onClose()->exec();
var_dump($data);
die;

object(MagmaCore\DataObjectLayer\Drivers\MysqlDatabaseConnection)#242 (3) {
  ["pdoDriver":protected]=>
  string(5) "mysql"
  ["environment":"MagmaCore\DataObjectLayer\Drivers\MysqlDatabaseConnection":private]=>
  object(MagmaCore\DataObjectLayer\DataLayerEnvironment)#234 (2) {
    ["environmentConfiguration":protected]=>
    object(MagmaCore\DataObjectLayer\DataLayerConfiguration)#238 (1) {
      ["dataLayerConfiguration":"MagmaCore\DataObjectLayer\DataLayerConfiguration":private]=>
      NULL
    }
    ["currentDriver":"MagmaCore\DataObjectLayer\DataLayerEnvironment":private]=>
    string(5) "mysql"
  }
  ["params":protected]=>
  array(4) {
    [20]=>
    bool(false)
    [12]=>
    bool(true)
    [3]=>
    int(2)
    [19]=>
    int(2)
  }
  ["dbh":"MagmaCore\DataObjectLayer\Drivers\AbstractDatabaseDriver":private]=>
  uninitialized(?object)
}

$create = new WidgetFactory;
$widget = $create->create(ClientRepositoryFactory::class, ['active_now_widget' => ['table' => 'user', 'table_id' => 'id']]);
$widget = $create->create(ClientRepositoryFactory::class, ['bounce_rate_widget' => ['table' => 'user', 'table_id' => 'id']]);

    
var_dump($widget->renderWidget());
var_dump($widget->renderWidget());
die;

    /**
     * This will prevent the active user  within the session from deleting and trashing their own account.
     * 
     * if the token route is active and it matches the userID from the current session and any 
     * of 4 defined action is being carried out. Then we want to prevent. The action from completing
     * We must also take into account when deleting via bulk. As this will allow the user to be trash
     *
     * @return void
     */
    public function disableDeleteCurrentUser(BeforeControllerActionEvent $event)
    {
        $userID = $event->getObject()->getSession()->get('user_id');
        $token = $event->getObject()->thisRouteID();
        $action = $event->getMethod();
        $controller = $event->getObject()->thisRouteController();
        $postData = $event->getObject()->formBuilder->getData();
        $user = $event->getObject()->repository->getUser($userID);

        if (
            array_key_exists('bulkTrash-' . $controller, $postData) || 
            array_key_exists('bulkClone-' . $controller, $postData)) {
            if (in_array($userID, $postData['id'])) {
                $event->getObject()->flashMessage(sprintf('The action was reject. Because an item in your bulk selection is yourself [id = %s]', $userID), $event->getObject()->flashWarning());
                $event->getObject()->redirect('/admin/user/index');
            }
        } else if (isset($token) && $token === $userID && in_array($action, self::PREVENTION_ROUTES)) {
            $event->getObject()->flashMessage(sprintf('The action was reject. The action is not permitted on yourself  [id = %s]', $userID), $event->getObject()->flashWarning());
            $event->getObject()->redirect('/admin/user/index');
        }

                
    }

        /**
         * t1 = users
         * t2 = user_preferences
         * t3 = user_metadata
         * t4 = user_note
         *         $sql = "SELECT t2.permission_name FROM role_permission as t1 JOIN permissions as t2 ON t1.permission_id = t2.id WHERE t1.role_id = :role_id";

         */
        //$sql = 'SELECT * FROM users, user_metadata, user_preferences, user_note, user_role WHERE users.id = user_metadata.user_id AND user_preferences.user_id AND user_note.user_id AND user_role.user_id AND users.id = 1270';
        // $sql = 'SELECT * 
        // FROM users 
        //     INNER JOIN user_preferences 
        //         USING (user_id) 
        //     INNER JOIN user_metadata 
        //         USING (user_id) 
        //     INNER JOIN user_note 
        //         USING (user_id) 
        //     ORDER BY id';


        // $sql = 'SELECT * FROM 
        // users t1 
        //     LEFT JOIN user_preferences t2 
        //         ON t1.id = t2.user_id
        //     LEFT JOIN user_metadata t3
        //         ON t1.id = t3.user_id
        //     LEFT JOIN user_note t4
        //         ON t1.id = t4.user_id
        //     LEFT JOIN user_role t5
        //         ON t1.id = t5.user_id
        //     WHERE t1.id = :id
        // ';


        // $data = $this->repository->getRepo()->getEm()->getCrud()->rawQuery($sql, ['id' => 1270], 'fetch_all');

        $relationship = $this->repository->relationship(function($baseModel){
            return $baseModel
                ->addParent($this->repository)->select('t1') /* optional second argument $selectors can select what to return */
                ->addChild(UserMetadataModel::class, fn($baseModel, $model) => $baseModel->leftJoin($model::FOREIGNKEY, 't2'))
                ->addChild(UserNoteModel::class, fn($baseModel, $model) => $baseModel->leftJoin($model::FOREIGNKEY, 't3'))
                ->addChild(UserPreferenceModel::class, fn($baseModel, $model) => $baseModel->leftJoin($model::FOREIGNKEY, 't4'))
                ->addChild(UserRoleModel::class, fn($baseModel, $model) => $baseModel->leftJoin($model::FOREIGNKEY, 't5'))
                ->where(1270) /* optional use where() when a single item is required. argument required in item ID */
                ->getRelations(); /* must return this method at the end */
        });

        // $this->dump($relationship);
        echo $this->restful->response($relationship);
        die;

