complete update for changing user role from user section
16/07/2021

1. /*
RolePermissionAssignedActionSubscriber.php
ensure permission isn't already assigned before assigned to avoid duplicate entry error
*/

/*
Features

1. MVC design architecture
2. Custom PHP Framework
3. FormBuilder Component
4. PSR Caching Component
5. Session Management Component (requires Cookie Manager component)
6. Flash Messaging Component (requires Session Management Component)
7. PSR Logger component
8. Cookie Manager Component
9. Templating Component
10. Mailer component
11. UserManager Component (requires Authentication component)
12. Authentication Component
13. DataView Component
14.
*/
06/08/2021

1. render an alert on all main channel (index route) stating whether a route is unprotected ie has no permission can do this
using PHP Reflection to get all methods and check the a database if the route exists

2. create a fillable property for each model listing all fillable fields

use MagmaCore\Bundler\Bundler;
use MagmaCore\Blank\BlankBundler;
use MagmaCore\Container\ContainerFactory;

//$bundler = new Bundler((new ContainerFactory())->create(), ROOT_PATH);
//$bundler
//    ->addBundle(BlankBundler::register())
//    ->boot($bundler);
//
//$blanker = $bundler->getBundle('blanker');
//$blanker->set('name', 'Ricardo Miller');
//echo $blanker->get('name');
//var_dump($blanker);
//die;

use MagmaCore\DataObjectLayer\DataLayerClientFacade;
$client = new DataLayerClientFacade('plugin', 'user_role', 'id');

$all = $client->getClientRepository();
var_dump($all->get());
die;

php bin/console magma:create test_controller

use MagmaCore\Utility\Yaml;
// use MagmaCore\Bundler\Bundler;
use MagmaCore\Logger\LogLevel;
// use MagmaCore\Blank\BlankBundler;
use MagmaCore\Base\BaseApplication;
use MagmaCore\Http\Request;
// use MagmaCore\Container\ContainerFactory;

// $bundler = new Bundler((new ContainerFactory())->create(), ROOT_PATH);
// $bundler->addBundle(BlankBundler::register())->boot($bundler);

// $blanker = $bundler->getBundle('blanker');
// $blanker->set('name', 'Ricardo Miller');
// echo $blanker->get('name');
// var_dump($blanker);
// die;
// $request = new Request('http://bbc.co.uk');
// $request->execute();
// $response = $request->checkResponseForContent();
// var_dump($response);
// die;


$path = '';
$data = null;
$headers = [];

$read = new CurlApi(
    'https://api.publicapis.org/',
    'random?auth=null',
    $headers
);
$data = $read->show()->response()->onClose()->exec();
var_dump($data);
die;

object(MagmaCore\DataObjectLayer\Drivers\MysqlDatabaseConnection)#242 (3) {
  ["pdoDriver":protected]=>
  string(5) "mysql"
  ["environment":"MagmaCore\DataObjectLayer\Drivers\MysqlDatabaseConnection":private]=>
  object(MagmaCore\DataObjectLayer\DataLayerEnvironment)#234 (2) {
    ["environmentConfiguration":protected]=>
    object(MagmaCore\DataObjectLayer\DataLayerConfiguration)#238 (1) {
      ["dataLayerConfiguration":"MagmaCore\DataObjectLayer\DataLayerConfiguration":private]=>
      NULL
    }
    ["currentDriver":"MagmaCore\DataObjectLayer\DataLayerEnvironment":private]=>
    string(5) "mysql"
  }
  ["params":protected]=>
  array(4) {
    [20]=>
    bool(false)
    [12]=>
    bool(true)
    [3]=>
    int(2)
    [19]=>
    int(2)
  }
  ["dbh":"MagmaCore\DataObjectLayer\Drivers\AbstractDatabaseDriver":private]=>
  uninitialized(?object)
}

$create = new WidgetFactory;
$widget = $create->create(ClientRepositoryFactory::class, ['active_now_widget' => ['table' => 'user', 'table_id' => 'id']]);
$widget = $create->create(ClientRepositoryFactory::class, ['bounce_rate_widget' => ['table' => 'user', 'table_id' => 'id']]);

    
var_dump($widget->renderWidget());
var_dump($widget->renderWidget());
die;

    /**
     * This will prevent the active user  within the session from deleting and trashing their own account.
     * 
     * if the token route is active and it matches the userID from the current session and any 
     * of 4 defined action is being carried out. Then we want to prevent. The action from completing
     * We must also take into account when deleting via bulk. As this will allow the user to be trash
     *
     * @return void
     */
    public function disableDeleteCurrentUser(BeforeControllerActionEvent $event)
    {
        $userID = $event->getObject()->getSession()->get('user_id');
        $token = $event->getObject()->thisRouteID();
        $action = $event->getMethod();
        $controller = $event->getObject()->thisRouteController();
        $postData = $event->getObject()->formBuilder->getData();
        $user = $event->getObject()->repository->getUser($userID);

        if (
            array_key_exists('bulkTrash-' . $controller, $postData) || 
            array_key_exists('bulkClone-' . $controller, $postData)) {
            if (in_array($userID, $postData['id'])) {
                $event->getObject()->flashMessage(sprintf('The action was reject. Because an item in your bulk selection is yourself [id = %s]', $userID), $event->getObject()->flashWarning());
                $event->getObject()->redirect('/admin/user/index');
            }
        } else if (isset($token) && $token === $userID && in_array($action, self::PREVENTION_ROUTES)) {
            $event->getObject()->flashMessage(sprintf('The action was reject. The action is not permitted on yourself  [id = %s]', $userID), $event->getObject()->flashWarning());
            $event->getObject()->redirect('/admin/user/index');
        }

                
    }
